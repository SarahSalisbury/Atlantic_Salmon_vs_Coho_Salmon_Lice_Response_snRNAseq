---
title: "Coho Salmon Prepration"
author: "Sarah Salisbury"
output:
  html_document:
    toc: true
    number_sections: true
---

# Getting Your Data

## Setting up R Environment

### Setup
```{r setup}
# Prevent scientific notation output (e.g., we don't want very small p-values to be output as say 10^-9)
options(scipen=999)
#set seed for reproducibility
set.seed(42) #note that UMAPs use seed of 42, not sure if setting seed here overrides this.
```

### Load Packages

Now load up all of the packages you'll need for this analysis

```{r load packages}
# Load up libraries
library(Seurat) # to run single cell analyses
library(ggplot2) # to make plots
library(dplyr) # to manipulate data frames
library(cowplot) # to arrange plots in a grid
library(data.table) # to use %like%
library(glmGamPoi) # helps to speed up SCTransform step
library("DoubletFinder") # to detect doublets in our dataset
```

## Read and Initialize the Seurat object

### Read STARsolo output folder

We can load the STARsolo output using the "Read10X" command. Set the path for each sample to the appropriate folder containing your "genes.tsv.gz", "barcodes.tsv.gz" and "matrix.mtx.gz" files.

Please note that these files MUST be gzipped before being read by the "Read10X" command (STARsolo outputs these files in an unzipped format so you must complete the gzipping yourself).

Note that we're going to read the feature names from the first column of the features.tsv file rather than the default second column ```, ("gene.column = 1"``` at the end of your ```Read10X``` command.). The first column has the ENSEMBL ID, the second has the gene symbol OR Ensembl ID (if no gene symbol). We're doing this (instead of the default 2nd column which sometimes has the gene name) because our list of orthologs has only the ENSEMBL gene IDs. Don't worry, we will get back to the gene names for Atlantic Salmon later.

```{r load data}
# Load data
# Please note that if you are running this locally you may have to run it line by line (not as a chunk) because R tends to freeze when importing such large files.
### CHANGE PATHS AS APPROPRIATE ###
#SKIN#
CO.sample25 <- Read10X(data.dir = "fin_01_sept_22/COout/lib25cohomtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
CO.sample24 <- Read10X(data.dir = "fin_01_sept_22/COout/lib24cohomtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
CO.sample33 <- Read10X(data.dir = "fin_01_sept_22/COout/lib33cohomtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
CO.sample37 <- Read10X(data.dir = "fin_01_sept_22/COout/lib37cohomtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
CO.sample34 <- Read10X(data.dir = "fin_01_sept_22/COout/lib34cohomtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
CO.sample41 <- Read10X(data.dir = "fin_01_sept_22/COout/lib41cohomtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)

#FIN#
CO.sample44 <- Read10X(data.dir = "fin_01_sept_22/COout/lib44cohomtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
CO.sample45 <- Read10X(data.dir = "fin_01_sept_22/COout/lib45cohomtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
CO.sample16 <- Read10X(data.dir = "fin_01_sept_22/COout/lib16cohomtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
CO.sample09 <- Read10X(data.dir = "fin_11_may_22/out/lib9cohomulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
CO.sample28 <- Read10X(data.dir = "fin_01_sept_22/COout/lib28cohomtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
CO.sample10 <- Read10X(data.dir = "fin_11_may_22/out/lib10cohomulticore1passmultimapnmax10/Solo.out/GeneFull/raw/", gene.column = 1)
```
##### Make Table of Gene Symbols Matched to ENSEMBL IDs for AS

Please note that the gene names are identical for some features in some genomes, particularly those which are polyploid. For example, there are two genes labeled "mcm5" in the ENSEMBL annotation for Atlantic Salmon ( Ssal_v3.1). R can not handle this so it automatically adds a decimal and then a number (e.g. ".1") after the second or greater instance of a gene name when you import the features from the features.tsv file. This is ptentially a problem because later on during analysis we may want to know the location of each copy of a single gene (e.g., which gene is "mcm5.1" and which is "mcm5"). There are a couple ways to tackle this as outlined here (https://github.com/satijalab/seurat/issues/1867). One way is to force R to read the feature names from the first column of the features.tsv file rather than the default second column. The first column has the ENSEMBL ID, the second has the gene symbol OR Ensembl ID (if no gene symbol). If you want to do that you could simply add ```, "gene.column = 1"``` at the end of your ```Read10X``` command.

Because it's easier to be using the gene symbols when possible, instead of using ENSEMBL IDs we're going to create a table that indicates the ENSEMBL ID of each gene symbol, so in future if we want to know this information we can just consult this table (taken from https://github.com/satijalab/seurat/issues/1867).

# NOTE THIS IS NOT A MISTAKE, WE NEED ATLANTIC SALMON CODES LATER!!!
```{r make gene symbol ENSEMBL ID table}
# Read in the unzipped features.tsv file for one of your samples

### CHANGE PATH AS APPROPRIATE ###
genes_AS <- read.table("fin_11_may_22/out/lib7v3.2mtmulticore1passmultimapnmax10/Solo.out/GeneFull/raw/features.tsv", stringsAsFactors = F)

# Now make the second column (with gene symbols) unique. this let's the first instance of each gene symbols keep it unchanged, but all subsequent gene symbols get a suffix like ".1", ".2", etc.
genes_AS$V2 <- make.unique(genes_AS$V2)

# Please write out this table as a reference noting the gene symbol with the Ensembl ID for each feature
write.csv(genes_AS, "FEATUREEnsembltosymbolAS.csv")
```
Please note that it is acceptable to use a single features.tsv file for all samples AS LONG AS THEY WERE ALL ANNOTATED WITH THE SAME INDEXED GENOME USING STARsolo! This will result in identical features.tsv files. Please note also that these features.tsv files will also be identical between "raw" and "filtered" directories. This is because STARsolo filters out cells NOT features.

### Converting CO to AS annotations

Ok so we want to annotate the Coho libraries with the Atlantic Salmon genes, based on 1-to-1 orthologs, as determined using Orthofinder.

So we're going to take each Coho dataset that we loaded in and we're going to replace the Coho named genes with Atlantic Salmon named genes.
```{r}
# Read in the orthogroup file, specify no strings as factors and that there is no header in this file
orthogroups <- fread("../ORTHOGROUPS/Orthogroups_1geneperspecies.tsv", stringsAsFactors = FALSE, header = FALSE)

#Let's make some appropriate column names:
colnames(orthogroups) <- c("Orthogroup", "AS", "CH", "CO", "PI") # for Atlantic Salmon, Chum Salmon, Coho Salmon, Pink Salmon, respectively

# Have a look to make sure that worked
head(orthogroups)

# Great but notice that there is no "gene:" in front of the ENSEMBL genes, so we need to add this so we can merge this file with our feature samples from each library
# So we're saying go to the beginning of the line "^" and capture the whole line "(.*)" and then add "gene:" in front and print what was captures "\\1"
orthogroups$CO <- sub("^(.*)$", "gene:\\1", orthogroups$CO)
orthogroups$AS <- sub("^(.*)$", "gene:\\1", orthogroups$AS)

# We also need to get rid of the suffixes (.1, .2) for the gene codes in the orthogroups file (we don't have these in our library files).
# Remember that because a period indicates any character (it's a special character), we need to "escape" this special nature using the "\\" to get R to read the period as a period.

#Please note that the Atlantic salmon has two suffixes (.1 and .2) while the Coho Salmon only has one suffix (.1). I don't think this is an issue though, because as you'll there's no genes that have the same core name with a different suffix.
orthogroups$AS <- gsub("\\.1$", "", orthogroups$AS)
orthogroups$AS <- gsub("\\.2$", "", orthogroups$AS)
orthogroups$CO <- gsub("\\.1$", "", orthogroups$CO)

# get just the Atlantic salmon orthologous genes
orthogroups_testAS <- orthogroups$AS

#how many genes are there?
length(orthogroups_testAS)
#6494

# how many unique genes are there (once we have removed the suffixes)?
length(unique(orthogroups_testAS))
#6494

# Great, so this suggests no genes had the same core but different suffixes.

# Now get the rownames (features) for each of the samples
sample_features <- rownames(CO.sample25)
sample_features_24 <- rownames(CO.sample24)
sample_features_33 <- rownames(CO.sample33)
sample_features_37 <- rownames(CO.sample37)
sample_features_34 <- rownames(CO.sample34)
sample_features_41 <- rownames(CO.sample41)

sample_features_44 <- rownames(CO.sample44)
sample_features_45 <- rownames(CO.sample45)
sample_features_16 <- rownames(CO.sample16)
sample_features_09 <- rownames(CO.sample09)
sample_features_28 <- rownames(CO.sample28)
sample_features_10 <- rownames(CO.sample10)

# Ok so I think the features should be identical for all samples, because they were aligned against the same genome (and I believe every gene is listed even if it wasn't observed in the library)
# but just to double check I will see if each vector of gene names for each sample is equal to that for sample 25 using setequal(). https://www.geeksforgeeks.org/check-if-two-objects-are-equal-in-r-programming-setequal-function/
setequal(sample_features, sample_features_24) #TRUE
setequal(sample_features, sample_features_33) #TRUE
setequal(sample_features, sample_features_37) #TRUE
setequal(sample_features, sample_features_34) #TRUE
setequal(sample_features, sample_features_41) #TRUE

setequal(sample_features, sample_features_44) #TRUE
setequal(sample_features, sample_features_45) #TRUE
setequal(sample_features, sample_features_16) #TRUE
setequal(sample_features, sample_features_09) #TRUE
setequal(sample_features, sample_features_28) #TRUE
setequal(sample_features, sample_features_10) #TRUE

# Fantastic, so this means we only need to generate the new AS annotations once and can then apply it to all Coho samples.

sample_features_df <- data.frame(sample_features)

sample_features_df_rows <- mutate(sample_features_df, row = row_number())

# let's look at the gene names
sample_features_df_rows_ordered <- sample_features_df_rows[order(sample_features_df_rows$sample_features),]

head(sample_features_df_rows_ordered)
# so genes either start with "gene-" - for the mtDNA genes
# or they start with "gene:ENSOKI...

#Now let's merge the list of genes in our library with those in the orthogroups file, only keep genes in the library though

sample_features_df_rows_orthos <- merge(sample_features_df_rows, orthogroups, by.x = "sample_features", by.y = "CO", all.x = TRUE, all.y = FALSE)

#Have a look at genes with values for orthologs for other species
#https://sparkbyexamples.com/r-programming/remove-rows-with-na-in-r/
head(sample_features_df_rows_orthos[complete.cases(sample_features_df_rows_orthos), ])
# Note that there is 6494 rows! Which is consistent with the number of orthologs in our orthogroups file above!
nrow(sample_features_df_rows_orthos[complete.cases(sample_features_df_rows_orthos), ])

# Alright, but I don't just want the ENSEMBL code, I'd prefer to have the gene code where possible
# So let's load up the file for Atlantic Salmon that converts ENSEMBL code to gene symbol
AS_Ensembl_GeneSymbols <- fread("FEATUREEnsembltosymbolAS.csv", stringsAsFactors = FALSE, header = TRUE)

#Let's make some appropriate column names:
colnames(AS_Ensembl_GeneSymbols) <- c("Row_AS_File", "ENSEMBL", "ENSEMBL_or_GENE", "Gene", "Expression")

#So now let's merge the dataframe with the AS_Ensembl_GeneSymbols file:
sample_features_df_rows_orthos_genesymbol <- merge(sample_features_df_rows_orthos, AS_Ensembl_GeneSymbols, by.x = "AS", by.y = "ENSEMBL", all.x = TRUE, all.y = FALSE)

# Sort by the rownumber (corresponding to original row number of feature plot for Seurat objects)
sample_features_df_rows_orthos_genesymbol_ordered <- sample_features_df_rows_orthos_genesymbol[order(sample_features_df_rows_orthos_genesymbol$row),]

# Before we replace the <NA> values in the AS column (ENSEMBL_or_GENE), I want to know what values are in this column (I'll need this info later to filter for these genes in the Seurat objects).
# So get rid of the NAs in the ENSEMBL_or_GENE column and save this list of genes as a vector
# https://www.edureka.co/community/2093/how-to-remove-na-values-from-a-vector-in-r
set_of_orthogroups_to_merge_AS_CO <- sample_features_df_rows_orthos_genesymbol_ordered$ENSEMBL_or_GENE[!is.na(sample_features_df_rows_orthos_genesymbol_ordered$ENSEMBL_or_GENE)]

# Check that the number of genes in this list is correct
length(set_of_orthogroups_to_merge_AS_CO)
#6494, great, that's the length of the orthogroups file

# Ok, so I want to replace those <NA> values in the AS column (with either ENSEMBL or gene symbol name) with the Coho value
#https://stackoverflow.com/questions/34071875/replace-a-value-na-with-the-value-from-another-column-in-r
# so we'll use coalesce dplyr function
sample_features_df_rows_orthos_genesymbol_ordered_coalesced <- sample_features_df_rows_orthos_genesymbol_ordered %>%
  mutate(ENSEMBL_or_GENE = coalesce(ENSEMBL_or_GENE, sample_features))

# Ok just have a check to see that the genes are in the same order (remember that some genes have been replaced with their AS counterpart)
head(rownames(CO.sample33))
head(sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE)
# looks ok!

### so what you have now is orthologs will have the AS ENSEMBL or the gene symbol, all other genes will have the Coho ENSEMBL ID (this isn't a problem because we filter these out later so we're not going to be seeing them after SCTransform)
# But this is important for the CellCycleScoring because we need to make sure that our genes have the appropriate code, so if a cellcyclegene is in AS, we give it the symbol if one is available, else keep the ENSEMBL code, if the cellcyclegene is not in AS, we keep the CO ENSEMBL code

# Now replace the feature column in each of our samples
rownames(CO.sample25) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
rownames(CO.sample24) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
rownames(CO.sample33) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
rownames(CO.sample37) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
rownames(CO.sample34) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
rownames(CO.sample41) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE

rownames(CO.sample44) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
rownames(CO.sample45) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
rownames(CO.sample16) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
rownames(CO.sample09) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
rownames(CO.sample28) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
rownames(CO.sample10) <- sample_features_df_rows_orthos_genesymbol_ordered_coalesced$ENSEMBL_or_GENE
```

## Initialize the Seurat object

Now we will convert the 10X data into a Seurat object using "CreateSeuratObject" (https://www.rdocumentation.org/packages/Seurat/versions/3.1.4/topics/CreateSeuratObject).

Options:
counts - Unnormalized data such as raw counts or TPMs
project - Sets the project name for the Seurat object
min.cells - Include features (genes) detected in at least this many cells.
min.features - Include cells where at least this many features (genes) are detected.
```{r initialize seurat object}
# Make Seurat Object
# Specify that each feature must occur in atleast 3 cells, and each cell must have at least 200 features for all samples
#SKIN#
CO.seurat25 <- CreateSeuratObject(counts = CO.sample25, project = "CO_TX_skin", min.cells = 3, min.features = 200)
CO.seurat24 <- CreateSeuratObject(counts = CO.sample24, project = "CO_TA_skin", min.cells = 3, min.features = 200)
CO.seurat33 <- CreateSeuratObject(counts = CO.sample33, project = "CO_TB_skin", min.cells = 3, min.features = 200)
CO.seurat37 <- CreateSeuratObject(counts = CO.sample37, project = "CO_TC_skin", min.cells = 3, min.features = 200)
CO.seurat34 <- CreateSeuratObject(counts = CO.sample34, project = "CO_TD_skin", min.cells = 3, min.features = 200)
CO.seurat41 <- CreateSeuratObject(counts = CO.sample41, project = "CO_TE_skin", min.cells = 3, min.features = 200)

#FIN#
CO.seurat44 <- CreateSeuratObject(counts = CO.sample44, project = "CO_TX_PV_44", min.cells = 3, min.features = 200)
CO.seurat45 <- CreateSeuratObject(counts = CO.sample45, project = "CO_TA_PV_45", min.cells = 3, min.features = 200)
CO.seurat16 <- CreateSeuratObject(counts = CO.sample16, project = "CO_TB_PV", min.cells = 3, min.features = 200)
CO.seurat09 <- CreateSeuratObject(counts = CO.sample09, project = "CO_TC_PV", min.cells = 3, min.features = 200)
CO.seurat28 <- CreateSeuratObject(counts = CO.sample28, project = "CO_TD_PV", min.cells = 3, min.features = 200)
CO.seurat10 <- CreateSeuratObject(counts = CO.sample10, project = "CO_TE_PV", min.cells = 3, min.features = 200)
```

## Generate a list of samples to be used in this analysis
```{r id list}
# Make list of ids
### CHANGE AS APPROPRIATE ###
ids <- c("CO_TX_skin", "CO_TA_skin", "CO_TB_skin", "CO_TC_skin", "CO_TD_skin", "CO_TE_skin", "CO_TX_PV_44", "CO_TA_PV_45", "CO_TB_PV", "CO_TC_PV", "CO_TD_PV", "CO_TE_PV")
```

## Merge samples
Merge all of the samples into a single Seurat object using the "merge" function, which takes a Seurat object and then a list of additional Seurat objects ("y"). The "add.cell.ids" argument adds a metadata column ("orig.ident) identifying the sample of origin of each cell.
```{r merge samples}
# Merge samples

### CHANGE AS APPROPRIATE ###
CO <- merge(CO.seurat25, y = c(CO.seurat24, CO.seurat33, CO.seurat37, CO.seurat34, CO.seurat41, CO.seurat44, CO.seurat45, CO.seurat16, CO.seurat09, CO.seurat28, CO.seurat10), add.cell.ids = c("CO_TX_skin", "CO_TA_skin", "CO_TB_skin", "CO_TC_skin", "CO_TD_skin", "CO_TE_skin", "CO_TX_PV_44", "CO_TA_PV_45", "CO_TB_PV", "CO_TC_PV", "CO_TD_PV", "CO_TE_PV"), project = "CO")

# Check how many cells you have for each sample.
table(CO$orig.ident)
```
# Quality control

The main purpose of the QC is to retain only those cells that are likely to be real and relatively free of contamination/bias for further analysis.

## Identify mitochondrial genes

One of the key QC metrics of single-cell RNA-Seq is the percentage of mitochondrial RNA in each cell. Cells with a high proportion of mitochondrail RNA (> 10%) are generally considered low-quality / dying cells. We can use "PercentageFeatureSet" to estimate the percentage of counts originating from a set of features for each individual cell, and we can store this information as metadata. In some species the "pattern = '^MT-'" argument can be used to automatically detect mitochondrial genes (will depend on whether their names start with "MT-" on the genome annotation file), but in most of them the list of mitochondrial genes will have to be manually found and specified based on their annotation.

```{r identify mitochondrial genes}
# Here are all the mtDNA genes
# NOTE THAT WE HAD TO USE THE ENSEMBL IDS HERE BECAUSE THAT'S HOW WE LOADED IN THE SEURAT FILES!!!!
mtgenes <- c("gene-KEG53_p08","gene-KEG53_p09","gene-KEG53_p11","gene-KEG53_p10","gene-KEG53_p07","gene-KEG53_p01","gene-KEG53_r01","gene-KEG53_r02","gene-KEG53_t01","gene-KEG53_t02","gene-KEG53_t03","gene-KEG53_t04","gene-KEG53_t05","gene-KEG53_t06","gene-KEG53_t07","gene-KEG53_t08","gene-KEG53_t09","gene-KEG53_t10","gene-KEG53_t11","gene-KEG53_t12","gene-KEG53_t13","gene-KEG53_t14","gene-KEG53_t15","gene-KEG53_t16","gene-KEG53_t17","gene-KEG53_t18","gene-KEG53_t19","gene-KEG53_t20","gene-KEG53_t21","gene-KEG53_t22","gene-KEG53_p13","gene-KEG53_p12","gene-KEG53_p06","gene-KEG53_p04","gene-KEG53_p05","gene-KEG53_p03","gene-KEG53_p02")

#Ok but note that the "_" have been changed to "-" by Seurat, so we need to change that for our genes here too
mtgenes <- gsub("_","-",mtgenes)

# Now only some of these are actually in the feature list (some will have gotten filtered out because they didn't appear in more than 3 cells for example). We get an error if we ask Seurat to look for features which aren't present using "PercentFeatureSet" below, so we need to know which of the mtgenes above are actually in our feature list.
#So let's check which of our mtgenes are in the feature list and save this as mtgenesinfeaturelist
mtgenesinfeaturelist <- mtgenes[mtgenes %in% CO@assays$RNA@counts@Dimnames[[1]]]

# So which mtDNA genes are in our feature list?
mtgenesinfeaturelist

# Great job, now we're going to calculate the percentage of reads within each nuclei which are taken up by these mtDNA genes. Remember, we would expect none because we are sequencing nuclei not cells!

# Note that the [[ operator can add columns to object metadata. This is a great place to stash QC stats
CO[["percent.mt"]] <- PercentageFeatureSet(CO, features = mtgenesinfeaturelist)


# You might get an error here if there are not mitochondrial genes in your samples (which is what you'd expect when sequencing nuclei)
# If it runs successfully though then we need to have a look at the percentages per barcode (cell):

head(CO[["percent.mt"]])
```

## MtDNA

So we'd like to know how much mtDNA is generally found in each of our cells within each of our samples. This will help inform us as to what the cutoff should be for the maximum amount of mtDNA we will allow in a cell before it is removed.

### Violin Plot visualization of mtDNA percentage
```{r violin plot of mtDNA}
# Visualize QC metrics as a violin plot
VlnPlot(object = CO, features = c("percent.mt"), ncol = 1
        , pt.size = 0 # set pt.size to 0 to remove the points and just see the violins!
        ) + ###Note that this plot won't show up if we couldn't calculate percent.mt above because there are no mtDNA genes!
geom_hline(yintercept = c(10)) # add a horizontal line at 10% mtDNA percentage, can be changed as required
```

Alright so it's clearly there are some cells with super high mt DNA (percent,mt) we probably would be wise to get rid of thesm, the question is, where do you draw the line as to what is ok?

To help us make this decision, let's visualize the mtDNA percentage in a slightly different way.

### Ridgeplot visualization of mtDNA percentage
```{r ridgeplot of mtDNA}
RidgePlot(CO, features=c("percent.mt"), ncol = 1) + #set ncol to number of plots you want in each row
geom_vline(xintercept = c(10)) # add a vertical line at 10% mtDNA percentage, can be changed as required
```

### Distribution of mtDNA percentage by cell rank

Now let's visualize the mtDNA percentage distribution by cells ranked by mtDNA percentage.

Code modified from: https://ucdavis-bioinformatics-training.github.io/2022-March-Single-Cell-RNA-Seq-Analysis/data_analysis/scRNA_Workshop-PART1_fixed)
And from: https://stackoverflow.com/questions/26034177/save-multiple-ggplots-using-a-for-loop
```{r distribution of mtDNA by cell rank}
# We're going to save several plots in a list so generate an empty list
plot_list_mt = list()

#Now do a for loop that is as long as the number of samples in your Seurat object (ids)
for (i in 1:length(ids)) {
  datatoplot <- CO[[]] %>% filter (orig.ident == ids[i]) # our data to plot will be a subset of the Seurat object, including only the metadata for those cells which have the same sample id (orig.ident) as our input individual sample

  # Plot
  pl1 <- data.frame(index=seq.int(1,nrow(datatoplot)), # make a dataframe with an index value starting from 1 and going to the number of rows in our filtered metadata dataframe (equals the number of cells for our sample)
                    nFeature_RNA = sort(datatoplot$percent.mt,decreasing=F)) %>% # sort the number of genes per cell from the metadata in increasing order (because large number of mtDNA = bad)
    ggplot() + #let's make a ggplot figure
    scale_color_manual(values=c("green"), labels=c("percent.mt"), name=NULL) + # specify our colours, then specify color labels, set name = NULL so no legend title
    ggtitle(paste(ids[i], "Raw STARsolo cells",sep=" "), subtitle = "pre-filtered for cells with >= 200 genes, genes in >= 3 cells") + xlab("Barcodes") + ylab("Percentage mtDNA genes (%)") + # set title of figure, x-axis, y-axis
    geom_line(aes(x=index, y=nFeature_RNA, color = "percent.mt"), size=1.25) # plot the Feature counts

  plot_list_mt[[i]] = pl1 #add the figure to the list
}

# Relabel each plot in your list with the sample name:
names(plot_list_mt) <- ids

# Let's have a look at our plots
print(plot_list_mt)
```

We could do a 5% limit as this is also what Seurat uses in the tutorial: https://satijalab.org/seurat/articles/pbmc3k_tutorial.html. However, a natural end of the distribution seems to be at 10%, so we'll use the more liberal 10%.

### Distribution of mtDNA percentage by cell rank with cutoff plotted
```{r distribution of mtDNA by cell rank with cutoff plotted}
# So let's visualize these potential filtering limits on our distribution plots to make sure they're appropriate.

mt_upper <- 10

# Make a ggplot2 layer with horizontal lines for upper and lower limits for UMI
cellfiltermtDNA <- geom_hline(yintercept = c(mt_upper), color = "green")

# Add these lines to each of your distribution plots

#Now do a for loop that is as long as the number of samples in your Seurat object (ids)
for (i in 1:length(plot_list_mt)) {
 plot <- plot_list_mt[[i]] + cellfiltermtDNA # plot each of the previously generated mtDNA plots with the added horizontal line denoting upper limit on mtDNA
 plot_list_mt[[i]] = plot # save your plot to the list
}

# Let's have a look at our plots
print(plot_list_mt)

#Now let's save each of the plots as a .tiff file
for (i in 1:length(plot_list_mt)) { # for loop from one to number of samples
  file_name = paste("mtDNA_distribution_plot_", ids[i], ".tiff", sep="") # save a separate .tiff file for each sample, name it
  tiff(file_name)  # start making the .tiff file
  print(plot_list_mt[[i]]) # print the plot for the particular sample
  dev.off() # stop making the .tiff file
}

```

### Filter Cells by mtDNA percentage

So once you're happy with your filters that you've noted above then we can apply them to your data.
```{r filter cells by mtDNA percentage}
# Reset upper bound of mtDNA
mt_upper <- 10

# Keep only those cells with mtDNA percentage below this upper threshold
CO <- subset(CO, subset = percent.mt < mt_upper)

# Check how many remaining cells you have for each sample.
table(CO$orig.ident)
```

### Filter out mtDNA features

So we know that there shouldn't be any mtDNA genes in our dataset (because we're sequencing nuclei not cells). Therefore we're going to filter out all of the mtDNA genes from our feature list.

Code modified from: https://github.com/satijalab/seurat/issues/2610
```{r filter features by removing mtDNA}
# Get RNA counts array
counts <- GetAssayData(CO, assay = "RNA")

# Determine how many features you have before filtering.
nrow(counts)

# Get RNA counts array excluding (-) those rownames which are mtDNA genes
counts <- counts[-(which(rownames(counts) %in% mtgenes)),]

# Determine how many features you have after filtering.
nrow(counts)

# SANITY CHECK: Is the number of features before filtering equal to that after filtering equal plus the number of mtDNA features?
length(mtgenesinfeaturelist) + nrow(counts)

# Subset the Seurat object to include only those features which are in the rownames of the counts array
CO <- subset(CO, features = rownames(counts))
```

## Number of genes (features) and molecules (UMI) per cell

### Violin Plot visualization of features and UMIs
```{r Violin Plot visualization of features and UMIs}
# Visualize QC metrics as a violin plot
VlnPlot(object = CO, features = c("nFeature_RNA", "nCount_RNA"), ncol = 2
        , pt.size = 0
        )
# set pt.size to 0 to see the violins!

# Can be easier to see if you do them one by one:
VlnPlot(object = CO, features = c("nFeature_RNA"))
VlnPlot(object = CO, features = c("nCount_RNA"))
```
Alright so it's clearly there are some cells with super high number of genes (Features), RNA molecule counts (nCount_RNA), we probably would be wise to get rid of these, the question is, where do you draw the line?

To help us make this decision, let's visualize in a slightly different way:

### Scatterplot visualization of features and UMIs
```{r Scatterplot visualization of features and UMIs}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
scatterplot <- FeatureScatter(CO, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

scatterplot
```

For the comparison of feature founts with RNA molecule counts we can see that the number of genes (features) correlates with the number of RNA molecules (count) which makes sense. But again, we can see some cells with really high RNA molecule and gene counts.

### Ridgeplot visualization of features and UMIs
```{r Ridgeplot visualization of features and UMIs}
RidgePlot(CO, features=c("nFeature_RNA","nCount_RNA"), ncol = 2) + # set ncol to number of plots you want in each row
geom_vline(xintercept = c(10)) # add a vertical line at 10% mtDNA percentage, can be changed as required
```

### Plot feature and UMI counts per cell by cell rank

Now letâ€™s visualize the feature and UMI counts per cell distribution by cells ranked by feature and UMI count. These plots approximate those which are output from CellRanger (but which we don't have because we used STARsolo).

To help us in making our decision for hard upper and lower bounds of UMI and feature counts for each sample we're going to plot this data three times:
  1. Using a logarithmic scale for the y-axis (counts of features/UMIs), this is how this data is plotted by CellRanger (and it gives you a characteristic "knee" plot)
  2. Using an untransformed y-axis
  3. Only plotting the first 1000 ranked cells (to help identify upper bounds of feature/UMI counts)

Code modified from: https://ucdavis-bioinformatics-training.github.io/2022-March-Single-Cell-RNA-Seq-Analysis/data_analysis/scRNA_Workshop-PART1_fixed)
And from: https://ucdavis-bioinformatics-training.github.io/2022-March-Single-Cell-RNA-Seq-Analysis/data_analysis/scRNA_Workshop-PART1_fixed)

```{r Plot feature and UMI counts per cell by cell rank}
# 1. Feature/UMI distribution plot with logarithmic y-axis

# We're going to save several plots in a list so generate an empty list
plot_list_umiftlog = list()

#Now do a for loop that is as long as the number of samples in your Seurat object (ids)
for (i in 1:length(ids)) {

  # Setting up the plot space
  xbreaks = c(1,1e1,1e2,1e3,1e4,1e5,1e6) # for our plot we will have breaks along the x axis at the noted values
  xlabels = c("1","10","100","1000","10k","100K","1M") # we will label these breaks with the noted appropriate values
  ybreaks = c(1,2,5,10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,100000,200000,500000,1000000) # we will have breaks along the y axis at the noted values
  ylabels = c("1","2","5","10","2","5","100","2","5","1000","2","5","10k","2","5","100K","2","5","1M") # we will label these breaks with the noted appropriate values

  # Data
  datatoplot <- CO[[]] %>% filter (orig.ident == ids[i]) # our data to plot will be a subset of the Seurat object, including only the metadata for those cells which have the same sample id (orig.ident) as our input individual sample

  # Plot
  pl1 <- data.frame(index=seq.int(1,nrow(datatoplot)), # make a dataframe with an index value starting from 1 and going to the number of rows in our filtered metadata dataframe (equals the number of cells for our sample)
                    nCount_RNA = sort(datatoplot$nCount_RNA,decreasing=T), # sort the number of RNA molecules per cell from the metadata in decreasing order
                    nFeature_RNA = sort(datatoplot$nFeature_RNA,decreasing=T)) %>% # sort the number of genes per cell from the metadata in decreasing order
    ggplot() + #let's make a ggplot figure
    scale_color_manual(values=c("red2","blue4"), labels=c("Features","UMI"), name=NULL) + # specify our colours, then specify color labels, set name = NULL so no legend title
    ggtitle(paste(ids[i], "Raw STARsolo cells",sep=" "), subtitle = "pre-filtered for cells with >= 200 genes, genes in >= 3 cells") + xlab("Barcodes") + ylab("counts (UMI or Features)") + # set title of figure, x-axis, y-axis
    scale_x_continuous(trans = 'log2', breaks=xbreaks, labels = xlabels) + # set x axis
    scale_y_continuous(trans = 'log2', breaks=ybreaks, labels = ylabels) + # set y axis
    geom_line(aes(x=index, y=nCount_RNA, color = "UMI"), size=1.75) + # plot the RNA molecule counts
    geom_line(aes(x=index, y=nFeature_RNA, color = "Features"), size=1.25) # plot the Feature counts

  plot_list_umiftlog[[i]] = pl1 #add the figure to the list
}

# Relabel each plot in your list with the sample name:
names(plot_list_umiftlog) <- ids

# Let's have a look at our plots
print(plot_list_umiftlog)

# 2. Feature/UMI distribution plot with untransformed y-axis

# We're going to save several plots in a list so generate an empty list
plot_list_umiftuntransformed = list()

#Now do a for loop that is as long as the number of samples in your Seurat object (ids)
for (i in 1:length(ids)) {

  # Setting up the plot space
  ybreaks = c(1,2,5,10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,100000,200000,500000,1000000) # we will have breaks along the y axis at the noted values
  ylabels = c("1","2","5","10","2","5","100","2","5","1000","2","5","10k","2","5","100K","2","5","1M") # we will label these breaks with the noted appropriate values

  # Data
  datatoplot <- CO[[]] %>% filter (orig.ident == ids[i]) # our data to plot will be a subset of the Seurat object, including only the metadata for those cells which have the same sample id (orig.ident) as our input individual sample

  # Plot
  pl1 <- data.frame(index=seq.int(1,nrow(datatoplot)), # make a dataframe with an index value starting from 1 and going to the number of rows in our filtered metadata dataframe (equals the number of cells for our sample)
                    nCount_RNA = sort(datatoplot$nCount_RNA,decreasing=T), # sort the number of RNA molecules per cell from the metadata in decreasing order
                    nFeature_RNA = sort(datatoplot$nFeature_RNA,decreasing=T)) %>% # sort the number of genes per cell from the metadata in decreasing order
    ggplot() + # let's make a ggplot figure
    scale_color_manual(values=c("red2","blue4"), labels=c("Features","UMI"), name=NULL) + # specify our colours, then specify color labels, set name = NULL so no legend title
     ggtitle(paste(ids[i], "Raw STARsolo cells",sep=" "), subtitle = "pre-filtered for cells with >= 200 genes, genes in >= 3 cells") + xlab("Barcodes") + ylab("counts (UMI or Features)") + # set title of figure, x-axis, y-axis
    scale_y_continuous(trans = 'log2', breaks=ybreaks, labels = ylabels) + # set y axis
    geom_line(aes(x=index, y=nCount_RNA, color = "UMI"), size=1.75) + # plot the RNA molecule counts
    geom_line(aes(x=index, y=nFeature_RNA, color = "Features"), size=1.25) # plot the Feature counts

  plot_list_umiftuntransformed[[i]] = pl1 #add the figure to the list
}

# Relabel each plot in your list with the sample name:
names(plot_list_umiftuntransformed) <- ids

# Let's have a look at our plots
print(plot_list_umiftuntransformed)

# 3. Feature/UMI distribution plot with untransformed y-axis and only first 1000 cells

# We're going to save several plots in a list so generate an empty list
plot_list_umiftuntransformed_first1000 = list()

#Now do a for loop that is as long as the number of samples in your Seurat object (ids)
for (i in 1:length(plot_list_umiftuntransformed)) {
 plot <- plot_list_umiftuntransformed[[i]] + xlim(0,1000) # plot each of the previously generated plots with an x-limit of 1000
 plot_list_umiftuntransformed_first1000[[i]] = plot # save your plot to the list
}

# Relabel each plot in your list with the sample name:
names(plot_list_umiftuntransformed_first1000) <- ids

# Let's have a look at our plots
print(plot_list_umiftuntransformed_first1000)
```

### Replot feature and UMI counts per cell by cell rank with upper and lower bounds

So after looking at those plots, we need to make a decision as to what we think is a reasonable upper and lower bound for UMI and feature counts.

```{r Replot feature and UMI counts per cell by cell rank with limits}

# Now we can specify a different upper and lower UMI/feature limit for each sample if we wish.

# Remind us of the order of our samples:
ids

# Great, now set limits for each of our samples:
UMI_upper <- c(6000, 2000, 6000, 6000, 2000, 6000, 2000, 6000, 2000, 6000, 6000, 6000) # set upper UMI limit to 6000 for all samples
UMI_lower <- c(500, 300, 300, 500, 300, 300, 300, 500, 300, 300, 750, 750) # set lower UMI limit to 500 for all
Feature_upper <- c(3500, 1500, 3500, 3500, 1500, 3500, 1500, 3500, 1500, 3500, 3500, 3500) # set upper feature limit to 3500 for all samples
Feature_lower <- c(500, 300, 300, 500, 300, 300, 300, 500, 300, 300, 750, 750) # set upper feature limit to 500 for all

# 1. Feature/UMI distribution plot with logarithmic y-axis

# We're going to save several plots in a list so generate an empty list
plot_list_umiftlog_limits = list()

# Now do a for loop that is as long as the number of samples in your Seurat object (ids)
for (i in 1:length(plot_list_umiftlog)) {
  plot <- plot_list_umiftlog[[i]] +
    geom_hline(yintercept = c(UMI_lower[i], UMI_upper[i]), color = "blue4") +
    geom_hline(yintercept = c(Feature_lower[i], Feature_upper[i]), color = "red2")
  plot_list_umiftlog_limits[[i]] = plot # save your plot to the list
}

# Relabel each plot in your list with the sample name:
names(plot_list_umiftlog_limits) <- ids

# Let's have a look at our plots
print(plot_list_umiftlog_limits)

#Now let's save each of the plots as a .tiff file
for (i in 1:length(plot_list_umiftlog_limits)) { # for loop from one to number of samples
  file_name = paste("UMIfeature_distribution_plot_log_", ids[i], ".tiff", sep="") # save a separate .tiff file for each sample, name it
  tiff(file_name)  # start making the .tiff file
  print(plot_list_umiftlog_limits[[i]]) # print the plot for the particular sample
  dev.off() # stop making the .tiff file
}

# 2. Feature/UMI distribution plot with untransformed y-axis

# We're going to save several plots in a list so generate an empty list
plot_list_umiftuntransformed_limits = list()

# Now do a for loop that is as long as the number of samples in your Seurat object (ids)
for (i in 1:length(plot_list_umiftuntransformed)) {
  plot <- plot_list_umiftuntransformed[[i]] +
    geom_hline(yintercept = c(UMI_lower[i], UMI_upper[i]), color = "blue4") +
    geom_hline(yintercept = c(Feature_lower[i], Feature_upper[i]), color = "red2")
  plot_list_umiftuntransformed_limits[[i]] = plot # save your plot to the list
}

# Relabel each plot in your list with the sample name:
names(plot_list_umiftuntransformed_limits) <- ids

# Let's have a look at our plots
print(plot_list_umiftuntransformed_limits)

# Now let's save each of the plots as a .tiff file
for (i in 1:length(plot_list_umiftuntransformed_limits)) { # for loop from one to number of samples
  file_name = paste("UMIfeature_distribution_plot_untransformed_", ids[i], ".tiff", sep="") # save a separate .tiff file for each sample, name it
  tiff(file_name)  # start making the .tiff file
  print(plot_list_umiftuntransformed_limits[[i]]) # print the plot for the particular sample
  dev.off() # stop making the .tiff file
}

# 3. Feature/UMI distribution plot with untransformed y-axis and only first 1000 cells

# We're going to save several plots in a list so generate an empty list
plot_list_umiftuntransformed_first1000_limits = list()

# Now do a for loop that is as long as the number of samples in your Seurat object (ids)
for (i in 1:length(plot_list_umiftuntransformed_first1000)) {
  plot <- plot_list_umiftuntransformed_first1000[[i]] +
    geom_hline(yintercept = c(UMI_lower[i], UMI_upper[i]), color = "blue4") +
    geom_hline(yintercept = c(Feature_lower[i], Feature_upper[i]), color = "red2")
  plot_list_umiftuntransformed_first1000_limits[[i]] = plot # save your plot to the list
}

# Relabel each plot in your list with the sample name:
names(plot_list_umiftuntransformed_first1000_limits) <- ids

# Let's have a look at our plots
print(plot_list_umiftuntransformed_first1000_limits)

# Now let's save each of the plots as a .tiff file
for (i in 1:length(plot_list_umiftuntransformed_first1000_limits)) { # for loop from one to number of samples
  file_name = paste("UMIfeature_distribution_plot_untransformed_first1000_", ids[i], ".tiff", sep="") # save a separate .tiff file for each sample, name it
  tiff(file_name)  # start making the .tiff file
  print(plot_list_umiftuntransformed_first1000_limits[[i]]) # print the plot for the particular sample
  dev.off() # stop making the .tiff file
}

# 4. Now let's look at all these plots together
FeatureUMIplots <- cowplot::plot_grid( # arrange plots using cowplot
  plot_list_umiftlog_limits[[1]], plot_list_umiftuntransformed_limits[[1]], plot_list_umiftuntransformed_first1000_limits[[1]],
  plot_list_umiftlog_limits[[2]], plot_list_umiftuntransformed_limits[[2]], plot_list_umiftuntransformed_first1000_limits[[2]],
  plot_list_umiftlog_limits[[3]], plot_list_umiftuntransformed_limits[[3]], plot_list_umiftuntransformed_first1000_limits[[3]],
  plot_list_umiftlog_limits[[4]], plot_list_umiftuntransformed_limits[[4]], plot_list_umiftuntransformed_first1000_limits[[4]],
  plot_list_umiftlog_limits[[5]], plot_list_umiftuntransformed_limits[[5]], plot_list_umiftuntransformed_first1000_limits[[5]],
  plot_list_umiftlog_limits[[6]], plot_list_umiftuntransformed_limits[[6]], plot_list_umiftuntransformed_first1000_limits[[6]],
  plot_list_umiftlog_limits[[7]], plot_list_umiftuntransformed_limits[[7]], plot_list_umiftuntransformed_first1000_limits[[7]],
  plot_list_umiftlog_limits[[8]], plot_list_umiftuntransformed_limits[[8]], plot_list_umiftuntransformed_first1000_limits[[8]],
  plot_list_umiftlog_limits[[9]], plot_list_umiftuntransformed_limits[[9]], plot_list_umiftuntransformed_first1000_limits[[9]],
  plot_list_umiftlog_limits[[10]], plot_list_umiftuntransformed_limits[[10]], plot_list_umiftuntransformed_first1000_limits[[10]],
  plot_list_umiftlog_limits[[11]], plot_list_umiftuntransformed_limits[[11]], plot_list_umiftuntransformed_first1000_limits[[11]],
  plot_list_umiftlog_limits[[12]], plot_list_umiftuntransformed_limits[[12]], plot_list_umiftuntransformed_first1000_limits[[12]],# order plots
  ncol = 3, # number of columns to arrange plots in
  nrow = 12 # number of rows to arrange plots in
)

# Save these plots
pdf(file = "DistributionsofFeaturesandUMIs.pdf", # name of file
    useDingbats=FALSE, # don't let R save your points as Dingbats characters
    width = 20, # specify width
    height = 10) # specify height
FeatureUMIplots # plot
dev.off() # save

# 5. Ok now let's replot our scatterplot with our limits added as a horizontal line for the Feature limits and vertical lines for the UMI limits
# We'll do this separately for each sample since we imposed different limits on each sample

# We're going to save several plots in a list so generate an empty list
plot_list_scatter = list()

# Now do a for loop that is as long as the number of samples in your Seurat object (ids)
for (i in 1:length(ids)) {

  # Data
  datatoplot <- subset(CO, subset = orig.ident == ids[i]) # our data to plot will be a subset of the Seurat object, including only the metadata for those cells which have the same sample id (orig.ident) as our input individual sample

  # Plot
  pl1 <- FeatureScatter(datatoplot, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") +
    ggtitle(paste("UMI and Features for", ids[i], sep=" ")) + # set title
    geom_hline(yintercept = c(Feature_lower[i], Feature_upper[i])) + geom_vline(xintercept = c(UMI_lower[i], UMI_upper[i]))

  plot_list_scatter[[i]] = pl1 #add the figure to the list
}

# Relabel each plot in your list with the sample name:
names(plot_list_scatter) <- ids

# Let's have a look at our plots
print(plot_list_scatter)

# Now let's save each of the plots as a .tiff file
for (i in 1:length(plot_list_scatter)) { # for loop from one to number of samples
  file_name = paste("UMIfeature_scatterplot_", ids[i], ".tiff", sep="") # save a separate .tiff file for each sample, name it
  tiff(file_name)  # start making the .tiff file
  print(plot_list_scatter[[i]]) # print the plot for the particular sample
  dev.off() # stop making the .tiff file
}
```

### Filter Cells by UMI/Feature Counts

So once you're happy with your filters that you've noted above then we can apply them to our data
```{r filter cells by UMI/feature counts}
# Set your limits
UMI_upper <- 6000
UMI_lower <- 500
Feature_upper <- 3500
Feature_lower <- 500

# Filter each sample individually
#SKIN
CO.CO_TX_skin <- subset(CO, subset = orig.ident == "CO_TX_skin" & nFeature_RNA > 500 & nFeature_RNA < 3500 & nCount_RNA > 500 & nCount_RNA < 6000)

CO.CO_TA_skin <- subset(CO, subset = orig.ident == "CO_TA_skin" & nFeature_RNA > 300 & nFeature_RNA < 1500 & nCount_RNA > 300 & nCount_RNA < 2000)

CO.CO_TB_skin <- subset(CO, subset = orig.ident == "CO_TB_skin" & nFeature_RNA > 300 & nFeature_RNA < 3500 & nCount_RNA > 300 & nCount_RNA < 6000)

CO.CO_TC_skin <- subset(CO, subset = orig.ident == "CO_TC_skin" & nFeature_RNA > 500 & nFeature_RNA < 3500 & nCount_RNA > 500 & nCount_RNA < 6000)

CO.CO_TD_skin <- subset(CO, subset = orig.ident == "CO_TD_skin" & nFeature_RNA > 300 & nFeature_RNA < 1500 & nCount_RNA > 300 & nCount_RNA < 2000)

CO.CO_TE_skin <- subset(CO, subset = orig.ident == "CO_TE_skin" & nFeature_RNA > 300 & nFeature_RNA < 3500 & nCount_RNA > 300 & nCount_RNA < 6000)

#FIN
CO.CO_TX_PV_44 <- subset(CO, subset = orig.ident == "CO_TX_PV_44" & nFeature_RNA > 300 & nFeature_RNA < 1500 & nCount_RNA > 300 & nCount_RNA < 2000)

CO.CO_TA_PV_45 <- subset(CO, subset = orig.ident == "CO_TA_PV_45" & nFeature_RNA > 500 & nFeature_RNA < 3500 & nCount_RNA > 500 & nCount_RNA < 6000)

CO.CO_TB_PV <- subset(CO, subset = orig.ident == "CO_TB_PV" & nFeature_RNA > 300 & nFeature_RNA < 1500 & nCount_RNA > 300 & nCount_RNA < 2000)

CO.CO_TC_PV <- subset(CO, subset = orig.ident == "CO_TC_PV" & nFeature_RNA > 300 & nFeature_RNA < 3500 & nCount_RNA > 300 & nCount_RNA < 6000)

CO.CO_TD_PV <- subset(CO, subset = orig.ident == "CO_TD_PV" & nFeature_RNA > 750 & nFeature_RNA < 3500 & nCount_RNA > 750 & nCount_RNA < 6000)

CO.CO_TE_PV <- subset(CO, subset = orig.ident == "CO_TE_PV" & nFeature_RNA > 750 & nFeature_RNA < 3500 & nCount_RNA > 750 & nCount_RNA < 6000)

# Merge samples
CO <- merge(CO.CO_TX_skin, y = c(CO.CO_TA_skin, CO.CO_TB_skin, CO.CO_TC_skin, CO.CO_TD_skin, CO.CO_TE_skin, CO.CO_TX_PV_44, CO.CO_TA_PV_45, CO.CO_TB_PV, CO.CO_TC_PV, CO.CO_TD_PV, CO.CO_TE_PV), add.cell.ids = c("CO_TX_skin", "CO_TA_skin", "CO_TB_skin", "CO_TC_skin", "CO_TD_skin", "CO_TE_skin", "CO_TX_PV_44", "CO_TA_PV_45", "CO_TB_PV", "CO_TC_PV", "CO_TD_PV", "CO_TE_PV"), project = "CO")

# Check how many remaining cells you have
table(CO$orig.ident)

#Write
cellspersampletable <-table(CO$orig.ident)
write.table(cellspersampletable, file = "cellspersampleaftermtandhardfilters")
```

## Compute cell cycle scores

One potential factor influencing gene expression in our cells is cell cycle stage. For instance, we'd expect cells which are undergoing mitosis to be expressing genes differently from those in say the DNA synthesis phase. We can attempt to adjust for this in Seurat by looking at genes which are characteristically expressed at certain cell cycle stages to try and determine what cell cycle stage a given cell was at when it was sampled. Once we know this we can then adjust the expression profile of cells based on their cell cycle stage to attempt to reduce differences in gene expression due to cell cycle stage.

Here is a good vignette in Seurat about this QC: https://satijalab.org/seurat/articles/cell_cycle_vignette.html#regress-out-cell-cycle-scores-during-data-scaling-1

### Get list of cell cycle marker genes for Humans

A list of cell cycle markers, from Tirosh et al, 2015, is loaded with Seurat.  We can segregate this list into markers of G2/M phase and markers of S phase. Please note that there is an updated gene set from 2019, for more details see https://rdrr.io/cran/Seurat/man/cc.genes.updated.2019.html. Seems largely the same but has MCM7 instead of MCM2, and CENPU instead of MLF1IP. We will just use the original list ```cc.genes``` because we're just going to investigate for the
```{r cell cycle markers for humans}
# Load S phase genes
s.genes.Seurat <- cc.genes$s.genes

# Load G2M phase genes
g2m.genes.Seurat <- cc.genes$g2m.genes

# Let's have a look
s.genes.Seurat
g2m.genes.Seurat
```

### Get list of cell cycle marker genes for your study organism

```{r cell cycle markers for study organism}
# Read in cell cycle genes
#NOTE THAT I HAD TO MAKE A NEW CELLCYCLEGENES LIST
#FIRST I HAD TO CONVERT TO CO ENSEMBL CODE
# THEN I HAD TO CONVERT THOSE GENES WITH AS ORTHOLOGS TO THE ATLANTIC SALMON ENSEMBL ID
# NOTE THAT I ALSO HAD TO CONVERT THOSE AS genes with symbols to their symbol too! SO the list is a mix of CO ENSEMBL IDS (if not an ortholog), AS ENSEMBL IDS (if an ortholog but no symbol), and AS symbols (if an ortholog with a symbol)
cellcyclegenes <- read.csv("../CELL_CYCLE_GENES/CellCycleGenesCOVRAI_ASCOconversionforCO_proof_final.csv")

# Have a look
head(cellcyclegenes)

# Pull out S phase genes
S.genes <- cellcyclegenes %>% dplyr::filter(Cycle == "S.gene") %>% dplyr::select(Ensembl_ID) %>% pull(Ensembl_ID) # note that the "pull" converts the identified column to a vector, handy!
S.genes

# Pull out the G2M phase genes
G2M.genes <- cellcyclegenes %>% dplyr::filter(Cycle == "G2M.gene") %>% dplyr::select(Ensembl_ID) %>% pull(Ensembl_ID)
G2M.genes
```

### Normalize Data

So before we can generate the cell cycle scores we need to normalize the data (we're going to normalize again based on the cell cycle scores later on using SCT and prior to doubletfinder).

Please see: https://github.com/satijalab/seurat/issues/1679 for why we need to run SCTransform or NormalizeData before doing cell cycle scoring.

But I am using NormalizeData() rather than SCTransform prior to calculating CellCycleScores(), as suggested here: https://github.com/satijalab/seurat/issues/3692.
```{r normalizedata normalization}
# split the dataset into a list of of seurat objects (one for each sample)
CO.list <- SplitObject(CO, split.by = "orig.ident")

# Normalize and identify variable features for each dataset independently using NormalizeData()
#By default, we employ a global-scaling normalization method â€œLogNormalizeâ€ that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in x[["RNA"]]@data, COUNTS ARE OK THOUGH (x[["RNA"]]@counts). We aren't going to use these lognormalized data for anything other than generating cell cycle scores, so just be careful later to not reference the x[["RNA"]]@data slot! Always refer to the SCT slot that we'll make later on!
CO.list <- lapply(X = CO.list, FUN = function(x) {
  x <- NormalizeData(x)
})
```

### Cell Cycle Scores

Please note, it's ok if you get "Warning: The following features are not present in the object: gene:ENSOKIG00005024494, gene:ENSOKIG00005024547", because these are FEN1, FEN1.1, which also weren't present in species specific filtering for Coho

Similarly, it's ok to get "Warning: The following features are not present in the object: gene:ENSOKIG00005022273", because this is cks2, which also wasn't present in species specific filtering for Coho

PLEASE NOTE THAT WE DID THE CELLCYCLESCORING LIST MANUALLY

```{r cell cycle scoring}
# Now we're going to assign each nuclei to a cell cycle stage based on their expression of the S.genes and the G2M.genes
CO.list <- lapply(X = CO.list, FUN = function(x) {
  x <- CellCycleScoring(object = x,
                        g2m.features = G2M.genes,
                        s.features = S.genes,
                        set.ident = TRUE,
                        assay = 'RNA') # ok so here, I think it will read the "data" slot by default, based on this code: https://github.com/satijalab/seurat/issues/3692
})

#Now if we look at the metadata, we can see some new columns: "S.Score", "G2M.Score", and "Phase", which indicates the predicted cell cycle score of each nuclei
head(CO.list$CO_TX_skin[[]])
```

## Dataset integration

### Clean up memory

```{r clean up memory before SCTransform}
# Clean up memory
# At this point you may be running out of memory
# Ok we're going to try and remove everything now except AS.list to free up some memory
rm(list=ls()[! ls() %in% c("CO.list", "set_of_orthogroups_to_merge_AS_CO")])
#https://www.tutorialspoint.com/how-to-remove-all-objects-except-one-or-few-in-r
```

### Filter out non 1-to-1 orthologous genes

Ok so we're going to remove all genes except those which are 1-to-1 orthologs across Atlantic Salmon, Coho Salmon, Pink Salmon, Chum Salmon.

Code modified from: https://github.com/satijalab/seurat/issues/2610
```{r filter features by removing non 1-to-1 orthologs}
# Read in the orthogroup file, specify no strings as factors and that there is no header in this file
orthogroups <- fread("../ORTHOLOGS/Orthogroups_1geneperspecies.tsv", stringsAsFactors = FALSE, header = FALSE)

#Let's make some appropriate column names:
colnames(orthogroups) <- c("Orthogroup", "AS", "CH", "CO", "PI") # for Atlantic Salmon, Chum Salmon, Coho Salmon, Pink Salmon, respectively

# Have a look to make sure that worked
head(orthogroups)

# Great but notice that there is no "gene:" in front of the ENSEMBL genes, so we need to add this so we can merge this file with our feature samples from each library
# So we're saying go to the beginning of the line "^" and capture the whole line "(.*)" and then add "gene:" in front and print what was captures "\\1"
orthogroups$CO <- sub("^(.*)$", "gene:\\1", orthogroups$CO)
orthogroups$AS <- sub("^(.*)$", "gene:\\1", orthogroups$AS)

# We also need to get rid of the suffixes (.1, .2) for the gene codes in the orthogroups file (we don't have these in our library files).
# Remember that because a period indicates any character (it's a special character), we need to "escape" this special nature using the "\\" to get R to read the period as a period.

#Please note that the Atlantic salmon has two suffixes (.1 and .2) while the Coho Salmon only has one suffix (.1). I don't think this is an issue though, because as you'll there's no genes that have the same core name with a different suffix.
orthogroups$AS <- gsub("\\.1$", "", orthogroups$AS)
orthogroups$AS <- gsub("\\.2$", "", orthogroups$AS)
orthogroups$CO <- gsub("\\.1$", "", orthogroups$CO)

# get just the Atlantic salmon orthologous genes
orthogroups_testAS <- orthogroups$AS

#how many genes are there?
length(orthogroups_testAS)
#6494

# how many unique genes are there (once we have removed the suffixes)?
length(unique(orthogroups_testAS))
#6494

# Great, so this suggests no genes had the same core but different suffixes.

#Fabulous job!

# Alright, but I don't just want the ENSEMBL code, I'd prefer to have the gene code where possible
# So let's load up the file for Atlantic Salmon that converts ENSEMBL code to gene symbol
AS_Ensembl_GeneSymbols <- fread("FEATUREEnsembltosymbolAS.csv", stringsAsFactors = FALSE, header = TRUE)

# Wonderful

#Let's make some appropriate column names:
colnames(AS_Ensembl_GeneSymbols) <- c("Row_AS_File", "ENSEMBL", "ENSEMBL_or_GENE", "Gene", "Expression")

# GREAT JOB!

#So now let's merge the dataframe with the AS_Ensembl_GeneSymbols file:
sample_features_df_orthos_genesymbol <- merge(orthogroups, AS_Ensembl_GeneSymbols, by.x = "AS", by.y = "ENSEMBL", all.x = TRUE, all.y = FALSE)

# I want to know what values are in the ENSEMBL_or_GENE column (I'll need this info later to filter for these genes in the Seurat objects).
# So get rid of the NAs in the ENSEMBL_or_GENE column and save this list of genes as a vector
# https://www.edureka.co/community/2093/how-to-remove-na-values-from-a-vector-in-r
set_of_orthogroups_to_merge_AS_CO <- sample_features_df_orthos_genesymbol$ENSEMBL_or_GENE[!is.na(sample_features_df_orthos_genesymbol$ENSEMBL_or_GENE)]

# Check that the number of genes in this list is correct
length(set_of_orthogroups_to_merge_AS_CO)
#6494, great, that's the length of the orthogroups file


# Great, now we need to remove all genes except the ortho ones
CO.list <- lapply(X = CO.list, FUN = function(x) {
  
  # First get which orthogenes are in the list of features for the library
  orthogenesinfeaturelist <- set_of_orthogroups_to_merge_AS_CO[set_of_orthogroups_to_merge_AS_CO %in% x@assays$RNA@counts@Dimnames[[1]]]
  
  # Print out how many of these genes there are
  # Paste the unique "orig.ident" for each library to get the sample ID
  print(paste(unique(x$orig.ident), "number of ortho genes in initially loaded feature list (excluding genes in less than three cells and also mtDNA genes)=", length(orthogenesinfeaturelist)))
  
  # Get RNA counts array
  counts <- GetAssayData(x, assay = "RNA")
  
  # Determine how many features you have before filtering.
  print(paste(unique(x$orig.ident), "number of genes in feature list before filtering (excluding genes in less than three cells and also mtDNA genes)=", nrow(counts)))
  
  # Get RNA counts array only for those rownames which are orthogroup genes
  counts <- counts[(which(rownames(counts) %in% set_of_orthogroups_to_merge_AS_CO)),]
  
  # Determine how many features you have after filtering.
  print(paste(unique(x$orig.ident), "number of genes in feature list after filtering (excluding genes in less than three cells and also mtDNA genes=", nrow(counts)))
  
  # Subset the Seurat object to include only those features which are in the rownames of the counts array
  subset(x, features = rownames(counts))
})

# Let's see how many genes there are per sample
CO.list

# Note that the list of genes in all of our samples seems to be the same, that's right because the samples were merged after removing mtDNA genes (and no subsequent genes were removed), so the genes in the RNA assay should be identical across samples.
# But note that once we remove genes from each individual sample, we should expect different numbers of variable genes in each sample.

# Please note that not all of the 6494 genes in our orthogroup file are found in the RNA counts array (because genes were removed due to not being in 3 or more cells and if they were mtDNA genes)
# Remember, we made our orthogroup file "set_of_orthogroups_to_merge_AS_CO" by merging the list of orthogroups  with the list of all genes on our genome, NOT the list of all genes in our Seurat file (which is less)
# So the length of the orthogroup file (6494) does not necessarily equal the number of these genes that occur in our Seurat objects.
```

### SCTransform normalization

Apply sctransform normalization again to remove confounding sources of variation: i.e. cell cycle stage. We will follow this vignette to use the "v2" version of SCTransform: https://satijalab.org/seurat/articles/sctransform_v2_vignette.html.

```{r SCTransform normalization 2 regressing out cell cycle stage}
# Regress out variation due to cell cycle stage, by including "S.Score" and "G2M.Score" as variables to regress out.
# The latest version of sctransform also supports using glmGamPoi package which substantially improves the speed of the learning procedure. It can be invoked by specifying method="glmGamPoi".
CO.list <- lapply(X = CO.list, FUN = function(x) {
  x <- SCTransform(x,
                   vst.flavor = "v2",
                   conserve.memory = TRUE,
                   vars.to.regress = c("S.Score", "G2M.Score"),  # could also regress on "percent.mt" if you hadn't removed these genes
                   variable.features.n = "all",
                   method = "glmGamPoi",
                   assay = "RNA", # do not worry, you are reading the "counts" slot of the "RNA" assay here, NOT the newly generated "data" slot with the logtransformed values made using NormalizeData
  # SEE: https://github.com/satijalab/seurat/issues/3692, https://github.com/satijalab/seurat/blob/b51801bc4b1a66aed5456473c9fe0be884994c93/R/preprocessing.R#L1224, https://github.com/satijalab/seurat/issues/2993
                   new.assay.name = "SCT") # this should overwrite the previous SCT assay (we didn't run SCT previously, so no worries anyway)
})
```
```{r Sanity Check for Default Assay 2}
#Please note that the default assay has been switched to "SCT"
#For example:
DefaultAssay(object = CO.list$CO_TX_skin)
```

### Identifying Cell Clusters in Each Sample

Before we can run Doubletfinder we need to first identify putative clusters within each sample. This involves a few steps:
1. Generate a PCA
2. Select the best number of dimensions (PCs) to be used going forward by consulting an Elbowplot of PCs from PCA
3. Generate a UMAP
4. Cluster Cells

Please note that you have to look at the elbowplot and adjust the number of PCs to be used going forward!

Code for "lapply" modified from: https://stackoverflow.com/questions/65133609/name-multiple-plots-with-lapplyggplot-ggtitle-with-nested-list-name-accordin

For more information on FindNeighbours function see: https://satijalab.org/seurat/reference/findneighbors
For more information on clustering see: https://satijalab.org/seurat/articles/pbmc3k_tutorial.html
```{r identify cell clusters in each sample, message = FALSE}
# 1. Linear dimension reduction
# Run PCA for all of your samples individually with 50 PCs
CO.list <-lapply(X = CO.list, FUN = function(x) {
  x <- RunPCA(x, dims = 1:50)
})

# 2. Check how many PCs you need with an Elbowplot
# So we need to plot the standard deviation for each PC using an Elbowplot, you are looking for the point at which the curve bends appreciably towards a horizontal line
# This is pretty arbitrary so just try your best
# Here we are going to make an Elbowplot for each sample based on the 50 PCs we used to generate the PCA in the previous step
lapply(seq_along(CO.list), FUN = function(x) {
  ElbowPlot(CO.list[[x]], ndim = 50) +
    ggtitle(names(CO.list)[x]) # label the plots by samplename (the name of each Seurat object in CO.list)
})

#Ok so we'll say 20 PCs is ok for each of the samples

# 3. Make a UMAP
# Now we need to run the UMAP for each of our samples using the number of PCs we thought was appropriate from our Elbowplot
CO.list <- lapply(X = CO.list, FUN = function(x) {
  x <- RunUMAP(x, dims = 1:20) # This changes based on number of PCs appropriate from Elbowplot
})

# 4. Cluster cells
# Now we're going to cluster the cells in each sample into preliminary groups, these are needed by DoubletFinder to make artificial heterotropic doublets (i.e., doublets formed from the combination of two cells from different clusters/cell types)

# First thing to do is to calculate the neighbourhood overlap (Jaccard index) between every cell and its k.param nearest neighbors (https://satijalab.org/seurat/reference/findneighbors)
# use the same number of dimensions as used for UMAP
CO.list <- lapply(X = CO.list, FUN = function(x) {
  x <- FindNeighbors(x, dims = 1:20)
})

# Now we use that neighbourhood information to figure out which cells belong together in a cluster. The resolution parameter sets the "granularity" of the clustering, so higher values will give you more clusters. This seems like a bit of a dark art. https://satijalab.org/seurat/articles/pbmc3k_tutorial.html
CO.list <- lapply(X = CO.list, FUN = function(x) {
  x <- FindClusters(x, resolution = 0.2) # Potentially play with "resolution = 0.5"
})

# Plot the UMAP, for each sample (split.by = "orig.ident"), and label the clusters, set point size to 0.1, and don't add a legend
lapply(X = CO.list, FUN = function(x) {
DimPlot(x, reduction = "umap", split.by = "orig.ident", label = TRUE, pt.size = 0.1) + NoLegend()
})
```

### DoubletFinder

Doubletfinder (https://github.com/chris-mcginnis-ucsf/DoubletFinder) is a program that lets you find potential "doublets", that is cell barcodes that actually contain the RNA of more than one cell/nucleus. This occurs when you load a lot of cells on the Chromium 10X for example, sometimes multiple cells/nuclei might be captured in the oil droplet with a single cell barcoding bead.

DoubletFinder can be broken up into 4 steps:
1. Generate artificial doublets from existing scRNA-seq data
2. Pre-process merged real-artificial data
3. Perform PCA and use the PC distance matrix to find each cell's proportion of artificial k nearest neighbors (pANN)
4. Rank order and threshold pANN values according to the expected number of doublets

Do not apply DoubletFinder to aggregated scRNA-seq data representing multiple distinct samples (e.g., multiple 10X lanes). For example, if you run DoubletFinder on aggregated data representing WT and mutant cell lines sequenced across different 10X lanes, artificial doublets will be generated from WT and mutant cells, which cannot exist in your data. These artificial doublets will skew results. Notably, it is okay to run DoubletFinder on data generated by splitting a single sample across multiple 10X lanes.

Ensure that input data is cleared of low-quality cell clusters. There are a variety of ways to do this, but one usually uses the following workflow:
1. Manually threshold raw gene expression matrices according to RNA nUMIs (especially important when dealing with super-loaded 10X data because of the way CellRanger threholds data -- See Lun et al., 2019, Genome Biology.
2. Pre-process data using standard workflow.
3. Identify clusters with (A) low RNA UMIs, (B) High % mitochondrial reads, and/or (C) Uninformative marker genes.
4. Remove clusters, pre-process again, and run DoubletFinder.

Ok so I already did the raw manual threshold (initial reading in cells with 200 or more features, and only including features in 3 or more cells), I preprocessed the data, removing cells with low RNA UMIs and high % mtDNA reads, I then ran RunPCA() and RunUMAP() for each sample so we are ok to go ahead.

DoubletFinder is sensitive to heterotypic doublets -- i.e., doublets formed from transcriptionally-distinct cell states -- but is insensitive to homotypic doublets -- i.e., doublets formed from transcriptionally-similar cell states. In our original manuscript, we suggested using DoubletFinder to predict the number of doublets expected from Poisson statistical estimates realting to the droplet microfluidics cell loading density. However, Poisson estimates are agnostic of homotypic doublets, and will thus invariably overestimate the number of detectable doublets.

There are several key parameters to run DoubletFinder:
pN - this is the proportion of artificial doublets that are created by DoubletFinder from your sample's cells (so basically the program just picks two cells randomly from your data and merges their UMI/feature counts together). So apparently DoubletFinder isn't affected so much by this parameter, so the authors' suggest setting pN to 0.25 for all DoubletFinder applications and instead optimizing the pK parameter.
pK - this is the size of the cell's "neighbourhood" in gene expression space when calculating the proportion of artificial nearest neighbours score (pANN score). The pANN score is simply the number of artificial doublets in a cell's neighbourhood divided by the total number of cells in the cell's neighbourhood. So the idea is that if a cell has a lot of artificial doublets as neighbours then it is probably a doublet too! The neighbourhood size is the most important parameter to get right, so this is done by testing for the best pK using paramSweep_v3.

```{r clean up memory before doubletfinder}
# Clean up memory
# At this point you may be running out of memory again
# Ok we're going to try and remove everything now except CO.list and our list of orthologs
rm(list=ls()[! ls() %in% c("CO.list", "set_of_orthogroups_to_merge_AS_CO")])
#https://www.tutorialspoint.com/how-to-remove-all-objects-except-one-or-few-in-r
```

```{r doubletfinder simulate best parameters, message = FALSE, results = 'hide'}
# pK Identification (no ground-truth, meaning we don't know which cells are really doublets)
#So paramSweep_v3 "Performs pN-pK parameter sweeps on a 10,000-cell subset of a pre-processed Seurat object. Will use all cells if Seurat object contains less than 10,000 cells. Results are fed into 'summarizeSweep' and 'find.pK' functions during optimal pK parameter selection workflow. Parameters tested: pN = 0.05-0.3, pK = 0.0005-0.3."
# https://rdrr.io/github/chris-mcginnis-ucsf/DoubletFinder/man/paramSweep_v3.html
# use the same number of dimensions as used for UMAP
sweep.res.list_CO <- lapply(X = CO.list, FUN = function(x) {
  x <- paramSweep_v3(x, PCs = 1:20, sct = TRUE)
})

# Now we run summarizeSweep which "Summarizes results from doubletFinder_ParamSweep, computing the bimodality coefficient across pN and pK parameter space."
# https://rdrr.io/github/chris-mcginnis-ucsf/DoubletFinder/man/summarizeSweep.html
sweep.stats.list_CO <- lapply(X = sweep.res.list_CO, FUN = function(x) {
  x <- summarizeSweep(x, GT = FALSE)
})

#Now we're going to caculate the mean-variance-normalized bimodality coefficient (BCmvn) of pANN distributions produced using the parameter sweeps above. Apparently, BCmvn can be used to identify the pK that separates singlets and doublets the best. Basically you want a high value of the BCmvn metric for a particular pK value which indicates it is the one we want to use for our doublet detections.
bcmvn.list_CO <- lapply(X = sweep.stats.list_CO, FUN = function(x) {
  x <- find.pK(x)
})

#Convert pK column to numeric from factor
#We want pK values to be listed as numbers because later on we're going to find the highest value
bcmvn.list_CO <- lapply(X = bcmvn.list_CO, FUN = function(x) {
  x$pK <- as.numeric(as.character(x$pK))
  return(x)
})
```
```{r doubletfinder choose best pK value}
#Now we'll plot the BCmvn values for each sample
lapply(seq_along(bcmvn.list_CO), FUN = function(x) {
 ggplot(bcmvn.list_CO[[x]], aes(pK, BCmetric)) +
    geom_point() +
    ggtitle(names(bcmvn.list_CO)[x]) # title the plots by sample (the name of each list of BCmvn values)
})

#Ok now we want to find the maximum BCmvn value for each sample
# So using dplyr please filter the bcmvn dataframe for the maximum value in the BCmetric column, then just select the pK value, and then "pull" to convert the column to a vector
pK <- lapply(X = bcmvn.list_CO, FUN = function(x) {
  x %>% dplyr::filter(BCmetric == max(BCmetric)) %>% dplyr::select(pK) %>% pull(pK)
})
```
```{r doubletfinder find doublets, message = FALSE, results = 'hide'}
# Number of expected doublets given a Poisson distribution
# So the number of doublets we expect in our samples is given by the number of cells in our sample (the number of rows in our Seurat's metadata) multiplied by the doublet formation rate we expect for our sample. Now this doublet formation rate is an important parameter! Seems to be some variation in the literature on what this parameter should be. It's also possible that we should consider a different doublet formation rate for each library, but this could be a little bit annoying to do. For now, I'm going to use a 4% doublet formation rate, which is what 10X expects the multiplet rate to be when you load ~8250 cells and get ~5000 cells actually sequenced which is in the ball park for our samples (see page 18 of the Chromium Next GEM Single Cell 3' Reagent Kits v3.1 (Dual Index) User Guide: CG000315 Rev C).
nExp_poi <- lapply(X = CO.list, FUN = function(x) {
  x <- round(0.04*nrow(x@meta.data))  ## Assuming 4% doublet formation rate - tailor for your dataset
})

# Homotypic Doublet Proportion Estimate
# Now the thing is, DoubletFinder is pretty bad at identifying homotypic doublets (doublets formed from combining two cells of the same type), and so the the number of doublets we expect based on the Poisson distribution is actually an overestimation of the doublets that DoubletFinder can be expected to find.
# So we'll estimate the proportion of homotypic doublets we'd expect given the clustering we did above for each sample (e.g., given the cluster of all of the cells, what's the likelihood of combining two cells of the same cluster).
# So we don't know the cell types yet, so we'll just rely upon the "unsupervised clustering" we performed on our cells above as recommended by the DoubletFinder paper.
homotypic.prop <- lapply(X = CO.list, FUN = function(x) {
  x <- modelHomotypic(x@meta.data$seurat_clusters)
})

# Now we're going to estimate the number of heterotypic doublets in each of our samples by multiplying the number of doublets we expect (given Poisson distribution) by 1 - the proportion of expected homotypic doublets (as calculated above), and then round the results.
# Note that we're using mapply to apply this analysis to multiple samples using different parameters for each sample, so mapply applies the noted function to the first elements in each argument (x,y), and then to the second elements in each argument (x,y), etc. So please note that x in this case is a list of the number of expected doublets (given Poisson distribution) for sample 3 then sample 6. Similarly y in this case is a list of the proportion of homotypic doublets expected for each sample: sample 3 then sample 6. So we use the first list entry in each of x and y (parameters for sample 3) then we use the second list entry in each of x and y (parameters for sample 6).
# I'm using SIMPLIFY = FALSE so we keep the output in a list format (rather than simplifying to a vector), so that we can be consistently using lists for all our data (I don't think it really matters though if you convert to a vector)
# https://stackoverflow.com/questions/8733650/force-mapply-to-return-a-list
nExp_poi.adj <- mapply(function(x,y) round(x*(1-y)), x = nExp_poi, y = homotypic.prop, SIMPLIFY = FALSE)

# Run DoubletFinder with varying classification stringencies
# Ok so now we're going to run doubletFinder to identify doublets, using the appropriate number of PCs as you determined using your Elbowplot above, we'll set pN to 0.25, we'll set pK to the one with the highest BCmvn score as determined above, we'll use the Poisson distribution based expected number of duplets (not excluding homotypic doublets yet), we'll also make sure to set sct to TRUE because we normalized our data using SCTransform originally (if you forget this flag then you get an error!).
CO.list <- mapply(function(x,y,z) doubletFinder_v3(x, PCs = 1:20, pN = 0.25, pK = y, nExp = z, reuse.pANN = FALSE, sct = TRUE), x = CO.list, y = pK, z = nExp_poi)

# Alright so we need the name of the second last column in the metadata which is the column giving you the pANN score
# We can ask for the names of the meta.data in reverse (rev) and then ask for the second value to give the second last column name
# (https://stackoverflow.com/questions/21781596/refer-to-the-last-column-in-r)
pANN_name <- lapply(X = CO.list, FUN = function(x) {
  x <- rev(names(x@meta.data))[2]
})

# Now we run doubletfinder again, but we don't need to calculate our pANN scores again, just use the ones we calculated already by setting reuse.pANN to the column of the metadata for each sample which has the pANN scores (as denoted by vector pANN_name). Then we can use all the same parameters as before but set the number of expected doublets this time (nExp) to that calculated after adjusting for homotypic doublets (nExp_poi.adj)
CO.list <- mapply(function(x,y,z,w) doubletFinder_v3(x, PCs = 1:20, pN = 0.25, pK = y, nExp = z, reuse.pANN = w, sct = TRUE), x = CO.list, y = pK, z = nExp_poi.adj, w = pANN_name)

#Quick sanity check, let's make sure the number of doublets identified in the metadata matches the number expected based on nExp_poi.adj

test <- lapply(X = CO.list, FUN = function(x) {
  x <- x@meta.data %>%
    select(tail(names(.), 1)) %>%
    table()
})

# Alright so we need the name of the last column in the metadata which is the column giving you the groupings (Singlet/Doublet)
#We can ask for the names of the meta.data in reverse (rev) and then ask for the first value to give the last column name
#(https://stackoverflow.com/questions/21781596/refer-to-the-last-column-in-r)
Doublet_name <- lapply(X = CO.list, FUN = function(x) {
  x <- rev(names(x@meta.data))[1]
})

#Ok to make this easier for me to plot, we're going to replace the last column in the metadata (which corresponds to the doubletfinder assignments using the homotypic-adjustment) to a common name for all samples, just to make it easier to reference when plotting. You've kept the name of the column though above with "Doublet_name".
CO.list <- lapply(X = CO.list, FUN = function(x) {
  names(x@meta.data)[ncol(x@meta.data)] <- "Homo_Adj_Doub_Ass"; # take the names of the columns of the metadata, and specify the column number equal to the number of columns in the metadata (i.e. the last column), and we're going to name this column now "Homo_Adj_Doub_Ass"
  x # now print out the data for each sample and save to CO.list
})
```
```{r doubletfinder plot results and filter}
#plot the umap again, but group cells by their assignment as a "Doublet" or "Singlet" based on homotypic adjusted DoubletFinder results
lapply(seq_along(CO.list), FUN = function(x) {
 DimPlot(CO.list[[x]], reduction = "umap", group.by = "Homo_Adj_Doub_Ass", label = TRUE, pt.size = 0.1) + NoLegend() +
    ggtitle(names(CO.list)[x]) # title the plots by sample (the name of each list of BCmvn values)
})

#Great job, so now we're going to filter out these doublets from our dataset:
CO.list_NoDoublets <- lapply(X = CO.list, FUN = function(x) {
  subset(x, subset = Homo_Adj_Doub_Ass == "Singlet")
})
```

```{r doubletfinder sanity check}
# Just sanity check that the number of samples in your new Seurat files is the number of Singlets from your doubletfinder analysis:
test
lapply(X = CO.list_NoDoublets, FUN = function(x) {
  x <- nrow(x@meta.data)
})
```

### Integration

```{r clean up memory before integration}
# Clean up memory
# At this point you may be running out of memory agai
# Ok we're going to try and remove everything now except CO.integrated to free up some memory
rm(list=ls()[! ls() %in% c("CO.list_NoDoublets", "set_of_orthogroups_to_merge_AS_CO")])
#https://www.tutorialspoint.com/how-to-remove-all-objects-except-one-or-few-in-r
```

### Save your list

You can save the object at this point so that it can easily be loaded back in without having to rerun the computationally intensive steps performed above, or easily shared with collaborators.
```{r save CO list}
saveRDS(CO.list_NoDoublets, file = "CO.list_NoDoublets.rds")
```

## Session Info

```{r session info}
sessionInfo()
```
